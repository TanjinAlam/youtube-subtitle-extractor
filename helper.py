import re
bad_words = ['-->','</c>']


with open('povkn8AgKig.en.txt') as oldfile, open('newfile.txt', 'w') as newfile:
    for line in oldfile:
        if not any(bad_word in line for bad_word in bad_words):
            newfile.write(line)


with open('newfile.txt') as result:
    uniqlines = set(result.readlines())
    with open('sub_out.txt', 'w') as rmdup:
        mylst = map(lambda each: each.strip("&gt;&gt;"), uniqlines)
        print(mylst)
        rmdup.writelines(set(mylst))


def fix_youtube_vtt_and_save(vtt_file_path, output_txt_path):
    """Fixes Youtube's autogenerated VTT subtitles and saves the result to a .txt file"""

    import webvtt

    pretty_subtitle = ''
    previous_caption_text = ''
    i = 1
    for caption in webvtt.read(vtt_file_path):

        if previous_caption_text == caption.text.strip():
            # if previous and current lines are `identical`, print the start time from the previous
            # and the end time from the current.
            pretty_subtitle += f"{i}\n{previous_caption_start} --> {caption.end}\n{previous_caption_text}\n\n"
            i += 1

        elif previous_caption_text == caption.text.strip().split("\n")[0]:
            # if the current caption is multiline, and the previous caption is equal to
            # the current's first line, just ignore the first line and move on with the second.
            previous_caption_text = caption.text.strip().split("\n")[1]
            previous_caption_start = caption.start
            last_caption_end = caption.end

        else:
            previous_caption_text = caption.text.strip()
            previous_caption_start = caption.start.strip()

    # Save the fixed subtitles to a .txt file
    with open(output_txt_path, 'w', encoding='utf-8') as output_file:
        output_file.write(pretty_subtitle)

# Example usage:
input_vtt_path = 'povkn8AgKig.en.vtt'
output_txt_path = 'povkn8AgKig.en.txt'
fix_youtube_vtt_and_save(input_vtt_path, output_txt_path)

